<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>talent_recommendation.BipartiteRecSys &#8212; RecSysAlgo 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script src="../../_static/documentation_options.js?v=01f34227"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for talent_recommendation.BipartiteRecSys</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>

<span class="kn">from</span> <span class="nn">torch_geometric.data</span> <span class="kn">import</span> <span class="n">HeteroData</span>
<span class="kn">from</span> <span class="nn">torch_geometric.transforms</span> <span class="kn">import</span> <span class="n">ToUndirected</span><span class="p">,</span> <span class="n">RandomLinkSplit</span>

<span class="kn">import</span> <span class="nn">torch_geometric.transforms</span> <span class="k">as</span> <span class="nn">T</span>
<span class="c1"># from torch_geometric.nn import SAGEConv, to_hetero</span>
<span class="kn">from</span> <span class="nn">torch_geometric.nn.conv</span> <span class="kn">import</span> <span class="n">MessagePassing</span><span class="p">,</span> <span class="n">GCNConv</span>
<span class="kn">from</span> <span class="nn">torch_geometric.nn</span> <span class="kn">import</span> <span class="n">HeteroConv</span><span class="p">,</span> <span class="n">RGCNConv</span><span class="p">,</span> <span class="n">SAGEConv</span>
<span class="kn">from</span> <span class="nn">torch_geometric.utils</span> <span class="kn">import</span> <span class="n">degree</span>

<span class="kn">import</span> <span class="nn">knowledge_algorithms.deep_learning.pytorch</span>
<span class="kn">from</span> <span class="nn">knowledge_algorithms.knowledge_graph.neo4j</span> <span class="kn">import</span> <span class="n">Neo4jAPI</span>
<span class="kn">from</span> <span class="nn">knowledge_algorithms.knowledge_graph.processors</span> <span class="kn">import</span> <span class="n">SequenceEncoder</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">from</span> <span class="nn">.metrics</span> <span class="kn">import</span> <span class="n">compute_auc</span><span class="p">,</span> <span class="n">compute_precision_recall_f1</span><span class="p">,</span> <span class="n">hit_at_k</span>


<div class="viewcode-block" id="get_hetero_conv_layer">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.get_hetero_conv_layer">[docs]</a>
<span class="k">def</span> <span class="nf">get_hetero_conv_layer</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">HeteroData</span><span class="p">,</span> <span class="n">conv_layer</span><span class="o">=</span><span class="n">SAGEConv</span><span class="p">,</span> <span class="n">aggr</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a heterogeneous convolution layer suitable for processing graph data with multiple types of edges. </span>
<span class="sd">    The function dynamically selects the convolution layer based on the provided `conv_layer` argument. </span>
<span class="sd">    It supports both `RGCNConv` and other convolution layers like `SAGEConv`. The function iterates over the </span>
<span class="sd">    different edge types in the provided `HeteroData` object and creates a convolution layer for each edge type.</span>

<span class="sd">    :param in_channels: The number of input channels (features).</span>
<span class="sd">    :type in_channels: int</span>
<span class="sd">    :param out_channels: The number of output channels (features).</span>
<span class="sd">    :type out_channels: int</span>
<span class="sd">    :param data: The heterogeneous graph data containing multiple types of edges.</span>
<span class="sd">    :type data: HeteroData</span>
<span class="sd">    :param conv_layer: The type of convolution layer to be used, defaults to SAGEConv.</span>
<span class="sd">                       Must be a class that can be instantiated with in_channels, out_channels, and other required arguments.</span>
<span class="sd">    :type conv_layer: type, optional</span>
<span class="sd">    :param aggr: The type of aggregation to use (&#39;sum&#39;, &#39;mean&#39;, &#39;max&#39;, etc.), defaults to &#39;sum&#39;.</span>
<span class="sd">    :type aggr: str, optional</span>
<span class="sd">    :return: An instance of `HeteroConv` with a dictionary mapping each edge type to its respective convolution layer.</span>
<span class="sd">    :rtype: HeteroConv</span>

<span class="sd">    The function is primarily used in graph neural network models that handle heterogeneous graph data, where</span>
<span class="sd">    the graph contains multiple types of nodes and edges. The choice of `conv_layer` and `aggr` allows for </span>
<span class="sd">    customization of the convolution operation based on the model&#39;s specific requirements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">conv_layer</span> <span class="o">==</span> <span class="n">RGCNConv</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">HeteroConv</span><span class="p">({</span>
            <span class="n">edge_type</span><span class="p">:</span> <span class="n">conv_layer</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge_type</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">edge_types</span>
        <span class="p">},</span> <span class="n">aggr</span><span class="o">=</span><span class="n">aggr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">HeteroConv</span><span class="p">({</span>
            <span class="n">edge_type</span><span class="p">:</span> <span class="n">conv_layer</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">num_relations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">add_self_loops</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge_type</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">edge_types</span>
        <span class="p">},</span> <span class="n">aggr</span><span class="o">=</span><span class="n">aggr</span><span class="p">)</span></div>



<div class="viewcode-block" id="HeteroGNN">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.HeteroGNN">[docs]</a>
<span class="k">class</span> <span class="nc">HeteroGNN</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A heterogeneous Graph Neural Network (GNN) module built using PyTorch. This class is designed for handling</span>
<span class="sd">    heterogeneous graph data with multiple types of nodes and edges. It constructs a neural network with a specified</span>
<span class="sd">    number of convolutional layers, which can be of a user-defined type.</span>

<span class="sd">    The network is composed of a sequence of convolutional layers with ReLU activations, except for the final layer.</span>
<span class="sd">    It is compatible with node feature dictionaries and edge index dictionaries.</span>

<span class="sd">    :param input_channels: The number of input channels (features).</span>
<span class="sd">    :type input_channels: int</span>
<span class="sd">    :param hidden_channels: The number of hidden channels in the middle layers.</span>
<span class="sd">    :type hidden_channels: int</span>
<span class="sd">    :param out_channels: The number of output channels (features) produced by the last layer.</span>
<span class="sd">    :type out_channels: int</span>
<span class="sd">    :param data: The heterogeneous graph data containing multiple types of edges.</span>
<span class="sd">    :type data: HeteroData</span>
<span class="sd">    :param num_conv_layers: The number of convolutional layers in the network, defaults to 3. Must be at least 2.</span>
<span class="sd">    :type num_conv_layers: int, optional</span>
<span class="sd">    :param conv_layer: The type of convolution layer to be used in the network, defaults to RGCNConv.</span>
<span class="sd">    :type conv_layer: type, optional</span>

<span class="sd">    :raises AssertionError: If the number of convolutional layers is less than 2.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; data = HeteroData() # Example data with multiple edge types</span>
<span class="sd">        &gt;&gt;&gt; input_channels = 128</span>
<span class="sd">        &gt;&gt;&gt; hidden_channels = 64</span>
<span class="sd">        &gt;&gt;&gt; out_channels = 32</span>
<span class="sd">        &gt;&gt;&gt; model = HeteroGNN(input_channels, hidden_channels, out_channels, data)</span>
<span class="sd">        &gt;&gt;&gt; x_dict, edge_index_dict = data.x_dict, data.edge_index_dict # Example node features and edge indices</span>
<span class="sd">        &gt;&gt;&gt; out = model(x_dict, edge_index_dict) # Perform forward pass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">hidden_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">HeteroData</span><span class="p">,</span> <span class="n">num_conv_layers</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">conv_layer</span><span class="o">=</span><span class="n">SAGEConv</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">assert</span><span class="p">(</span><span class="n">num_conv_layers</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_layer_list</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">ModuleList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_conv_layers</span> <span class="o">=</span> <span class="n">num_conv_layers</span>

        <span class="c1"># Define the first convolutional layer</span>
        <span class="n">conv1</span> <span class="o">=</span> <span class="n">get_hetero_conv_layer</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">hidden_channels</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">conv_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_layer_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conv1</span><span class="p">)</span>
        
        <span class="c1"># Define the middle convolutional layers</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_conv_layers</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conv_layer_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_hetero_conv_layer</span><span class="p">(</span><span class="n">hidden_channels</span><span class="p">,</span> <span class="n">hidden_channels</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>

        <span class="c1"># Define the third convolutional layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_layer_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_hetero_conv_layer</span><span class="p">(</span><span class="n">hidden_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>

<div class="viewcode-block" id="HeteroGNN.forward">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.HeteroGNN.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_dict</span><span class="p">,</span> <span class="n">edge_index_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The forward pass of the HeteroGNN.</span>

<span class="sd">        :param x_dict: A dictionary containing the node features for each node type.</span>
<span class="sd">        :type x_dict: Dict[str, torch.Tensor]</span>
<span class="sd">        :param edge_index_dict: A dictionary containing the edge indices for each edge type.</span>
<span class="sd">        :type edge_index_dict: Dict[str, torch.Tensor]</span>
<span class="sd">        :return: A dictionary containing the output node features for each node type after passing through the GNN layers.</span>
<span class="sd">        :rtype: Dict[str, torch.Tensor]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_conv_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_layer_list</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x_dict</span><span class="p">,</span> <span class="n">edge_index_dict</span><span class="p">)</span>
            <span class="n">x_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Final layer</span>
        <span class="n">x_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_layer_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">x_dict</span><span class="p">,</span> <span class="n">edge_index_dict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x_dict</span></div>
</div>

    

<div class="viewcode-block" id="load_configs">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.load_configs">[docs]</a>
<span class="k">def</span> <span class="nf">load_configs</span><span class="p">(</span><span class="n">configs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">check_keys</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load the configuration.</span>

<span class="sd">    :param configs: Either a dict or a yaml configuration file.</span>
<span class="sd">    :type configs: Union[dict, str]</span>
<span class="sd">    :param check_keys: check if the config contains the keys in the checklist</span>
<span class="sd">    :type check_keys: list[str]</span>
<span class="sd">    :return: configuration</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">configs</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">configs</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
    <span class="c1"># check if the configuration contains needed keys</span>
    <span class="k">if</span> <span class="n">check_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">check_keys</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">configs</span>
    <span class="k">return</span> <span class="n">configs</span></div>



<div class="viewcode-block" id="save_configs">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.save_configs">[docs]</a>
<span class="k">def</span> <span class="nf">save_configs</span><span class="p">(</span><span class="n">configs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save the configuration to a YAML file.</span>

<span class="sd">    :param configs: The configuration to save.</span>
<span class="sd">    :type configs: dict</span>
<span class="sd">    :param file_path: The file path where the configuration will be saved.</span>
<span class="sd">    :type file_path: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">configs</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">default_flow_style</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="transform_hetero_data_for_rec_sys">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.transform_hetero_data_for_rec_sys">[docs]</a>
<span class="k">def</span> <span class="nf">transform_hetero_data_for_rec_sys</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_data_split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                      <span class="n">num_val</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">num_test</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">is_undirected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                      <span class="n">neg_sampling_ratio</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">edge_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rev_edge_types</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms heterogeneous graph data for a recommendation system, with options to make the graph undirected</span>
<span class="sd">    and to split the data randomly.</span>

<span class="sd">    :param data: The input graph data.</span>
<span class="sd">    :type data: HeteroData</span>
<span class="sd">    :param random_data_split: If True, splits the data randomly into training, validation, and test sets, defaults to True.</span>
<span class="sd">    :type random_data_split: bool, optional</span>
<span class="sd">    :param num_val: The proportion of edges used for validation, defaults to 0.1.</span>
<span class="sd">    :type num_val: float, optional</span>
<span class="sd">    :param num_test: The proportion of edges used for testing, defaults to 0.0.</span>
<span class="sd">    :type num_test: float, optional</span>
<span class="sd">    :param is_undirected: Specifies if the split edges should be undirected, defaults to True.</span>
<span class="sd">    :type is_undirected: bool, optional</span>
<span class="sd">    :param neg_sampling_ratio: The ratio of negative samples for each positive sample, defaults to 0.0.</span>
<span class="sd">    :type neg_sampling_ratio: float, optional</span>
<span class="sd">    :param edge_types: List of edge types to consider for splitting, defaults to None.</span>
<span class="sd">    :type edge_types: list of tuples, optional</span>
<span class="sd">    :param rev_edge_types: List of reverse edge types, corresponding to `edge_types`, defaults to None.</span>
<span class="sd">    :type rev_edge_types: list of tuples, optional</span>
<span class="sd">    :return: Either the transformed data or a tuple of (train_data, val_data, test_data), depending on the flags.</span>
<span class="sd">    :rtype: HeteroData or (HeteroData, HeteroData, HeteroData)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; data = HeteroData() # Example graph data</span>
<span class="sd">        &gt;&gt;&gt; train_data, val_data, test_data = transform_hetero_data_for_rec_sys(</span>
<span class="sd">                data, num_val=0.15, num_test=0.05, edge_types=[(&quot;user&quot;, &quot;likes&quot;, &quot;item&quot;)])</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="k">def</span> <span class="nf">hash_edge_types</span><span class="p">(</span><span class="n">edge_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge_types</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">edge_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge_type</span> <span class="ow">in</span> <span class="n">edge_types</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">random_data_split</span><span class="p">:</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">RandomLinkSplit</span><span class="p">(</span>
            <span class="n">num_val</span><span class="o">=</span><span class="n">num_val</span><span class="p">,</span>
            <span class="n">num_test</span><span class="o">=</span><span class="n">num_test</span><span class="p">,</span>
            <span class="n">is_undirected</span><span class="o">=</span><span class="n">is_undirected</span><span class="p">,</span>
            <span class="n">neg_sampling_ratio</span><span class="o">=</span><span class="n">neg_sampling_ratio</span><span class="p">,</span>
            <span class="n">edge_types</span><span class="o">=</span><span class="n">hash_edge_types</span><span class="p">(</span><span class="n">edge_types</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[(</span><span class="s2">&quot;employee&quot;</span><span class="p">,</span> <span class="s2">&quot;workedIn&quot;</span><span class="p">,</span> <span class="s2">&quot;project&quot;</span><span class="p">)],</span>
            <span class="n">rev_edge_types</span><span class="o">=</span><span class="n">hash_edge_types</span><span class="p">(</span><span class="n">rev_edge_types</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[(</span><span class="s2">&quot;project&quot;</span><span class="p">,</span> <span class="s2">&quot;rev_workedIn&quot;</span><span class="p">,</span> <span class="s2">&quot;employee&quot;</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">train_data</span><span class="p">,</span> <span class="n">val_data</span><span class="p">,</span> <span class="n">test_data</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">val_data</span><span class="p">,</span> <span class="n">test_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="generate_negative_samples">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.generate_negative_samples">[docs]</a>
<span class="k">def</span> <span class="nf">generate_negative_samples</span><span class="p">(</span><span class="n">pos_edge_index</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="n">num_neg_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate negative samples.</span>

<span class="sd">    :param pos_edge_index: Tensor of shape [2, num_edges] representing positive edges.</span>
<span class="sd">    :param num_nodes: Tuple (num_employees, num_projects) - the number of nodes in each category.</span>
<span class="sd">    :param num_neg_samples: The number of negative samples to generate.</span>
<span class="sd">    :return: Tensor of negative samples.</span>
<span class="sd">    </span>

<span class="sd">    This step is crucial for effectively training your model, </span>
<span class="sd">    especially since the quality of the negative samples can significantly influence the model&#39;s performance.</span>

<span class="sd">    - Positive Samples:</span>
<span class="sd">        Positive samples are straightforward since they are the existing edges in your graph. </span>
<span class="sd">        For instance, if you&#39;re recommending projects to employees, </span>
<span class="sd">        your positive samples are the `(&#39;employee&#39;, &#39;workedIn&#39;, &#39;project&#39;)` edges.</span>

<span class="sd">    - Negative Samples:</span>
<span class="sd">        Generating negative samples is more challenging. </span>
<span class="sd">        You need to create pairs of nodes that do not have an existing edge between them. </span>
<span class="sd">        It&#39;s important that these negative samples are realistic; </span>
<span class="sd">        that is, they should be plausible but non-existent edges.</span>

<span class="sd">    Here&#39;s a simple approach to generate negative samples:</span>
<span class="sd">    </span>
<span class="sd">        1. Randomly select an &#39;employee&#39; node.</span>
<span class="sd">        2. Randomly select a &#39;project&#39; or &#39;position&#39; node.</span>
<span class="sd">        3. Check if this pair forms an edge in your graph. If not, it&#39;s a valid negative sample.</span>
<span class="sd">        4. Repeat this process until you have the desired number of negative samples.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Example usage</span>
<span class="sd">        &gt;&gt;&gt; num_employees = 10000</span>
<span class="sd">        &gt;&gt;&gt; num_projects = 4371  # or num_positions</span>
<span class="sd">        &gt;&gt;&gt; num_neg_samples = 10000  # This can be adjusted</span>

<span class="sd">        &gt;&gt;&gt; # Assuming you have your positive edge index for (&#39;employee&#39;, &#39;workedIn&#39;, &#39;project&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pos_edge_index = data[(&#39;employee&#39;, &#39;workedIn&#39;, &#39;project&#39;)].edge_index</span>
<span class="sd">        &gt;&gt;&gt; neg_edge_index = generate_negative_samples(pos_edge_index, (num_employees, num_projects), num_neg_samples)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neg_samples</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_neg_samples</span><span class="p">:</span>
        <span class="c1"># Randomly select an &#39;employee&#39; and a &#39;project/position&#39;</span>
        <span class="n">employee</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">project</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Check if this is a negative sample</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">pos_edge_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">employee</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pos_edge_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">project</span><span class="p">)):</span>
            <span class="n">neg_samples</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">employee</span><span class="p">,</span> <span class="n">project</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">neg_samples</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">pos_edge_index</span><span class="o">.</span><span class="n">device</span><span class="p">)</span></div>



<div class="viewcode-block" id="train">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.train">[docs]</a>
<span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">train_data</span><span class="p">:</span> <span class="n">HeteroData</span><span class="p">,</span> <span class="n">val_data</span><span class="p">:</span> <span class="n">HeteroData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">target_edge_type</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">loss_function</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;MarginRankingLoss&quot;</span><span class="p">,</span>
          <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Adam&quot;</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
          <span class="n">num_neg_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">loss_function_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;margin&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">},</span>
          <span class="n">optimizer_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">lr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span> <span class="n">k_to_hit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">val_per_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Train a model on heterogeneous graph data using specified loss function, optimizer, and evaluation metrics.</span>

<span class="sd">    :param model: The graph neural network model to be trained.</span>
<span class="sd">    :type model: torch.nn.Module</span>
<span class="sd">    :param train_data: The training dataset.</span>
<span class="sd">    :type train_data: HeteroData</span>
<span class="sd">    :param val_data: The validation dataset, defaults to None.</span>
<span class="sd">    :type val_data: HeteroData, optional</span>
<span class="sd">    :param target_edge_type: The target edge type for training, specified as a tuple (head, relation, tail).</span>
<span class="sd">    :type target_edge_type: tuple, optional</span>
<span class="sd">    :param loss_function: The loss function or its string identifier, defaults to &#39;MarginRankingLoss&#39;.</span>
<span class="sd">    :type loss_function: Union[torch.nn.Module, str], optional</span>
<span class="sd">    :param optimizer: The optimizer or its string identifier, defaults to &#39;Adam&#39;.</span>
<span class="sd">    :type optimizer: Union[torch.optim.Optimizer, str], optional</span>
<span class="sd">    :param num_epochs: The number of training epochs, defaults to 3.</span>
<span class="sd">    :type num_epochs: int, optional</span>
<span class="sd">    :param num_neg_samples: The number of negative samples per positive sample, defaults to None.</span>
<span class="sd">    :type num_neg_samples: int, optional</span>
<span class="sd">    :param loss_function_kwargs: Additional keyword arguments for the loss function, defaults to {&quot;margin&quot;: 0.5}.</span>
<span class="sd">    :type loss_function_kwargs: dict, optional</span>
<span class="sd">    :param optimizer_kwargs: Additional keyword arguments for the optimizer, defaults to {}.</span>
<span class="sd">    :type optimizer_kwargs: dict, optional</span>
<span class="sd">    :param lr: Learning rate for the optimizer, defaults to 0.001.</span>
<span class="sd">    :type lr: float, optional</span>
<span class="sd">    :param k_to_hit: The &#39;k&#39; value for hit rate calculation, defaults to 5.</span>
<span class="sd">    :type k_to_hit: int, optional</span>
<span class="sd">    :param device: The device to run the training on (CPU or CUDA), defaults to None.</span>
<span class="sd">    :type device: torch.device, optional</span>
<span class="sd">    :param val_per_epochs: Validation frequency (number of epochs), defaults to 10.</span>
<span class="sd">    :type val_per_epochs: int, optional</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; model = SomeGNNModel()</span>
<span class="sd">        &gt;&gt;&gt; train_data, val_data = load_hetero_data()  # Load your training and validation data</span>
<span class="sd">        &gt;&gt;&gt; train(model, train_data, val_data, target_edge_type=(&quot;user&quot;, &quot;interacts&quot;, &quot;item&quot;),</span>
<span class="sd">                  num_epochs=10, k_to_hit=10, lr=0.005)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">target_edge_type</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    
    <span class="c1"># ensure device</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
    <span class="n">train_data</span> <span class="o">=</span> <span class="n">train_data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Start training on </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2"> ...&quot;</span><span class="p">)</span>
    
    <span class="c1"># loss function</span>
    <span class="k">if</span> <span class="n">loss_function</span> <span class="o">==</span> <span class="s2">&quot;MarginRankingLoss&quot;</span><span class="p">:</span>
        <span class="n">loss_function</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">MarginRankingLoss</span><span class="p">(</span><span class="o">**</span><span class="n">loss_function_kwargs</span><span class="p">)</span>
        
    <span class="c1"># optimizer</span>
    <span class="k">if</span> <span class="n">optimizer</span> <span class="o">==</span> <span class="s2">&quot;Adam&quot;</span><span class="p">:</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span> <span class="o">**</span><span class="n">optimizer_kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">num_neg_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_neg_samples</span> <span class="o">=</span> <span class="n">train_data</span><span class="p">[</span><span class="n">target_edge_type</span><span class="p">]</span><span class="o">.</span><span class="n">num_edges</span>

    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">):</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>

        <span class="c1"># Forward pass through GNN</span>
        <span class="n">node_embeddings</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">train_data</span><span class="o">.</span><span class="n">x_dict</span><span class="p">,</span> <span class="n">train_data</span><span class="o">.</span><span class="n">edge_index_dict</span><span class="p">)</span>

        <span class="c1"># Assume you have a function to generate positive and negative samples</span>
        <span class="n">pos_samples</span> <span class="o">=</span> <span class="n">train_data</span><span class="p">[</span><span class="n">target_edge_type</span><span class="p">]</span><span class="o">.</span><span class="n">edge_index</span>
        <span class="n">neg_samples</span> <span class="o">=</span> <span class="n">generate_negative_samples</span><span class="p">(</span>
            <span class="n">pos_samples</span><span class="p">,</span> 
            <span class="p">(</span><span class="n">train_data</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">train_data</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">),</span> 
            <span class="n">num_neg_samples</span><span class="o">=</span><span class="n">num_neg_samples</span>
        <span class="p">)</span>

        <span class="c1"># Compute scores for positive and negative samples</span>
        <span class="c1"># Example: Using dot product to compute scores</span>
        <span class="n">pos_scores</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_embeddings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">pos_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">node_embeddings</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">pos_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">neg_scores</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_embeddings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">neg_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">node_embeddings</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">neg_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Target tensor for MarginRankingLoss</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">pos_scores</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Compute loss</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_function</span><span class="p">(</span><span class="n">pos_scores</span><span class="p">,</span> <span class="n">neg_scores</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

        <span class="c1"># Backward and optimize</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        
        <span class="c1"># Evaluate on validation set</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">val_per_epochs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">val_data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="c1"># Compute embeddings for validation set</span>
                    <span class="n">val_embeddings</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">val_data</span><span class="o">.</span><span class="n">x_dict</span><span class="p">,</span> <span class="n">val_data</span><span class="o">.</span><span class="n">edge_index_dict</span><span class="p">)</span>

                    <span class="c1"># Generate positive and negative samples for validation</span>
                    <span class="n">val_pos_samples</span> <span class="o">=</span> <span class="n">val_data</span><span class="p">[</span><span class="n">target_edge_type</span><span class="p">]</span><span class="o">.</span><span class="n">edge_index</span>
                    <span class="n">val_neg_samples</span> <span class="o">=</span> <span class="n">generate_negative_samples</span><span class="p">(</span>
                        <span class="n">val_pos_samples</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">val_data</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">val_data</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">),</span>
                        <span class="n">num_neg_samples</span><span class="o">=</span><span class="n">val_data</span><span class="p">[</span><span class="n">target_edge_type</span><span class="p">]</span><span class="o">.</span><span class="n">num_edges</span>
                    <span class="p">)</span>
                    
                    <span class="c1"># Compute scores for validation samples</span>
                    <span class="n">val_pos_scores</span> <span class="o">=</span> <span class="p">(</span><span class="n">val_embeddings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">val_pos_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">val_embeddings</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">val_pos_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">val_neg_scores</span> <span class="o">=</span> <span class="p">(</span><span class="n">val_embeddings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">val_neg_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">val_embeddings</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">val_neg_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    
                    <span class="c1"># compute validation loss</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">val_pos_scores</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">val_loss</span> <span class="o">=</span> <span class="n">loss_function</span><span class="p">(</span><span class="n">val_pos_scores</span><span class="p">,</span> <span class="n">val_neg_scores</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

                    <span class="c1"># Calculate metrics</span>
                    <span class="n">val_auc</span> <span class="o">=</span> <span class="n">compute_auc</span><span class="p">(</span><span class="n">val_pos_scores</span><span class="p">,</span> <span class="n">val_neg_scores</span><span class="p">)</span>
                    <span class="n">val_precision</span><span class="p">,</span> <span class="n">val_recall</span><span class="p">,</span> <span class="n">val_f1</span> <span class="o">=</span> <span class="n">compute_precision_recall_f1</span><span class="p">(</span><span class="n">val_pos_scores</span><span class="p">,</span> <span class="n">val_neg_scores</span><span class="p">)</span>
                    <span class="n">val_hit_k</span> <span class="o">=</span> <span class="n">hit_at_k</span><span class="p">(</span><span class="n">val_pos_scores</span><span class="p">,</span> <span class="n">val_neg_scores</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k_to_hit</span><span class="p">)</span>  <span class="c1"># You can adjust k</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch [</span><span class="si">{</span><span class="n">epoch</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">num_epochs</span><span class="si">}</span><span class="s2">], Loss: </span><span class="si">{</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">, Val Loss: </span><span class="si">{</span><span class="n">val_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Val AUC: </span><span class="si">{</span><span class="n">val_auc</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, Val Precision: </span><span class="si">{</span><span class="n">val_precision</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Val Recall: </span><span class="si">{</span><span class="n">val_recall</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, Val F1: </span><span class="si">{</span><span class="n">val_f1</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, Val Hit@</span><span class="si">{</span><span class="n">k_to_hit</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">val_hit_k</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch [</span><span class="si">{</span><span class="n">epoch</span><span class="o">+</span><span class="mi">1</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">num_epochs</span><span class="si">}</span><span class="s2">], Loss: </span><span class="si">{</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="rec_sys_train">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.rec_sys_train">[docs]</a>
<span class="k">def</span> <span class="nf">rec_sys_train</span><span class="p">(</span><span class="n">configs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">data</span><span class="p">:</span><span class="n">HeteroData</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Train a recommendation system model using heterogeneous graph data.</span>

<span class="sd">    This function trains a recommendation system model using heterogeneous graph data</span>
<span class="sd">    and saves the trained model and data configurations if specified.</span>

<span class="sd">    :param Union[dict, str] configs: Either a dictionary containing configuration parameters</span>
<span class="sd">        or a string specifying the path to a configuration file (in YAML format).</span>
<span class="sd">    :param HeteroData data: The heterogeneous graph data to be used for training.</span>
<span class="sd">    :param string device: The device to use for training (e.g., &quot;cpu&quot; or &quot;cuda&quot;).</span>
<span class="sd">    :param bool save: Whether to save the trained model and data configurations.</span>
<span class="sd">    </span>
<span class="sd">    :return: A trained recommendation system model and the input heterogeneous graph data.</span>
<span class="sd">    :rtype: Tuple[HeteroGNN, HeteroData]</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; configs = &quot;./my_configs.yaml&quot;</span>
<span class="sd">        &gt;&gt;&gt; model, data = rec_sys_train(configs)</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; model, data = rec_sys_train({&quot;neo4j&quot;: {&quot;url&quot;: &quot;http://localhost:7474&quot;, &quot;user&quot;: &quot;user&quot;, &quot;password&quot;: &quot;password&quot;}}, data)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># load configs</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">configs_file</span> <span class="o">=</span> <span class="n">configs</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">configs_file</span> <span class="o">=</span> <span class="s2">&quot;./configs.yaml&quot;</span>
    <span class="n">configs</span> <span class="o">=</span> <span class="n">load_configs</span><span class="p">(</span><span class="n">configs</span><span class="p">,</span> <span class="n">check_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">])</span>

    <span class="c1"># connect to neo4j database</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">Neo4jAPI</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">][</span><span class="s2">&quot;url&quot;</span><span class="p">],</span> <span class="n">configs</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">][</span><span class="s2">&quot;user&quot;</span><span class="p">],</span> <span class="n">configs</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">][</span><span class="s2">&quot;password&quot;</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connected to Neo4j Database.&quot;</span><span class="p">)</span>

    <span class="c1"># get the Hetero Dataset</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">HeteroData</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">load_hetero_graph_dataset</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">][</span><span class="s2">&quot;labels&quot;</span><span class="p">])</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">ToUndirected</span><span class="p">()(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">train_data</span><span class="p">,</span> <span class="n">val_data</span><span class="p">,</span> <span class="n">test_data</span> <span class="o">=</span> <span class="n">transform_hetero_data_for_rec_sys</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">configs</span><span class="p">[</span><span class="s2">&quot;dataTransform&quot;</span><span class="p">])</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">HeteroGNN</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">configs</span><span class="p">[</span><span class="s2">&quot;graphNeuralNetwork&quot;</span><span class="p">])</span>
    <span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">val_data</span><span class="p">,</span> <span class="n">target_edge_type</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="s2">&quot;targetEdgeType&quot;</span><span class="p">]),</span> <span class="o">**</span><span class="n">configs</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">save</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">save</span> <span class="o">=</span> <span class="s2">&quot;./checkpoints&quot;</span>
        <span class="n">save</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">save</span><span class="p">)</span>
        <span class="n">save</span><span class="o">.</span><span class="n">mkdir</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">save</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">configs</span><span class="p">[</span><span class="s1">&#39;save&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;model&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">save</span><span class="p">)),</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_dataset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">save</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="n">save_configs</span><span class="p">(</span><span class="n">configs</span><span class="o">=</span><span class="n">configs</span><span class="p">,</span> <span class="n">file_path</span><span class="o">=</span><span class="n">configs_file</span><span class="p">)</span>
        
    
    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">data</span></div>



<div class="viewcode-block" id="save_model">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.save_model">[docs]</a>
<span class="k">def</span> <span class="nf">save_model</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">HeteroGNN</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save a PyTorch model to a specified file path.</span>

<span class="sd">    This function saves a PyTorch model to a specified file path. If the path is a directory,</span>
<span class="sd">    the model will be saved as &quot;model.pt&quot; in that directory.</span>

<span class="sd">    :param HeteroGNN model: The PyTorch model to be saved.</span>
<span class="sd">    :param Union[str, Path] path: The file path where the model will be saved.</span>
<span class="sd">        If a directory is provided, the model will be saved as &quot;model.pt&quot; in that directory.</span>
<span class="sd">    </span>
<span class="sd">    :return: The absolute file path where the model was saved.</span>
<span class="sd">    :rtype: Path</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; model = HeteroGNN(...)</span>
<span class="sd">        &gt;&gt;&gt; saved_path = save_model(model, &quot;./models&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(saved_path)</span>
<span class="sd">        &#39;/path/to/models/model.pt&#39;</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; model = HeteroGNN(...)</span>
<span class="sd">        &gt;&gt;&gt; saved_path = save_model(model, &quot;./model.pth&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(saved_path)</span>
<span class="sd">        &#39;/path/to/model.pth&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
        <span class="n">path</span> <span class="o">/=</span> <span class="s2">&quot;model.pt&quot;</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span></div>



<div class="viewcode-block" id="load_model">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.load_model">[docs]</a>
<span class="k">def</span> <span class="nf">load_model</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">HeteroGNN</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a PyTorch model from a specified file path and set it to evaluation mode.</span>

<span class="sd">    This function loads a PyTorch model from a specified file path and sets it to evaluation mode.</span>
<span class="sd">    The model should have the same architecture as the one used during training.</span>

<span class="sd">    :param HeteroGNN model: The PyTorch model to be loaded.</span>
<span class="sd">    :param str path: The file path from which to load the model.</span>
<span class="sd">    </span>
<span class="sd">    :return: The loaded PyTorch model set to evaluation mode.</span>
<span class="sd">    :rtype: HeteroGNN</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; loaded_model = load_model(MyModel(), &quot;./models/model.pt&quot;)</span>
<span class="sd">        &gt;&gt;&gt; loaded_model.eval()</span>
<span class="sd">        &lt;HeteroGNN ...&gt;</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; loaded_model = load_model(MyModel(), &quot;./saved_models/model.pth&quot;)</span>
<span class="sd">        &gt;&gt;&gt; loaded_model.eval()</span>
<span class="sd">        &lt;HeteroGNN ...&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>  <span class="c1"># Set the model to evaluation mode</span>
    <span class="k">return</span> <span class="n">model</span></div>



<div class="viewcode-block" id="save_dataset">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.save_dataset">[docs]</a>
<span class="k">def</span> <span class="nf">save_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">HeteroData</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save a HeteroData object to a specified file path.</span>

<span class="sd">    This function saves a HeteroData object to a specified file path. If the path is a directory,</span>
<span class="sd">    the dataset will be saved as &quot;dataset.pt&quot; in that directory.</span>

<span class="sd">    :param HeteroData dataset: The HeteroData object to be saved.</span>
<span class="sd">    :param Union[str, Path] path: The file path where the dataset will be saved.</span>
<span class="sd">        If a directory is provided, the dataset will be saved as &quot;dataset.pt&quot; in that directory.</span>
<span class="sd">    </span>
<span class="sd">    :return: The absolute file path where the dataset was saved.</span>
<span class="sd">    :rtype: Path</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; dataset = MyHeteroData()</span>
<span class="sd">        &gt;&gt;&gt; saved_path = save_dataset(dataset, &quot;./datasets&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(saved_path)</span>
<span class="sd">        &#39;/path/to/datasets/dataset.pt&#39;</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; dataset = MyHeteroData()</span>
<span class="sd">        &gt;&gt;&gt; saved_path = save_dataset(dataset, &quot;./data/datafile.pth&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(saved_path)</span>
<span class="sd">        &#39;/path/to/data/datafile.pth&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
        <span class="n">path</span> <span class="o">/=</span> <span class="s2">&quot;dataset.pt&quot;</span>
    <span class="c1"># Convert HeteroData to a dictionary</span>
    <span class="n">dataset_dict</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="c1"># Save the dictionary as a PyTorch file</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dataset_dict</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span></div>



<div class="viewcode-block" id="load_dataset">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.load_dataset">[docs]</a>
<span class="k">def</span> <span class="nf">load_dataset</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a HeteroData object from a specified file path.</span>

<span class="sd">    This function loads a HeteroData object from a specified file path. If the path is a directory,</span>
<span class="sd">    the dataset will be loaded from &quot;dataset.pt&quot; in that directory.</span>

<span class="sd">    :param Union[str, Path] path: The file path from which to load the dataset.</span>
<span class="sd">    </span>
<span class="sd">    :return: The loaded HeteroData object.</span>
<span class="sd">    :rtype: HeteroData</span>

<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; loaded_dataset = load_dataset(&quot;./datasets&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(loaded_dataset)</span>
<span class="sd">    &lt;HeteroData ...&gt;</span>

<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; loaded_dataset = load_dataset(&quot;./data/datafile.pth&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(loaded_dataset)</span>
<span class="sd">    &lt;HeteroData ...&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
        <span class="n">path</span> <span class="o">/=</span> <span class="s2">&quot;dataset.pt&quot;</span>

    <span class="c1"># Load the dictionary and convert it back to HeteroData</span>
    <span class="n">dataset_dict</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">HeteroData</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dataset_dict</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">dataset</span></div>



<span class="c1">## for recommendation and similarity computation</span>

<div class="viewcode-block" id="json_to_feature_vector">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.json_to_feature_vector">[docs]</a>
<span class="k">def</span> <span class="nf">json_to_feature_vector</span><span class="p">(</span><span class="n">json_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">sentence_encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert JSON data to a feature vector using a sentence encoder.</span>

<span class="sd">    This function takes a JSON dictionary as input and converts it into a feature vector</span>
<span class="sd">    using a specified sentence encoder model.</span>

<span class="sd">    :param dict json_data: The JSON data to be converted to a feature vector.</span>
<span class="sd">    :param Union[SequenceEncoder, str] sentence_encoder: An instance of a sentence encoder model,</span>
<span class="sd">        or the name/directory path of a pre-trained sentence encoder model to be used for encoding.</span>
<span class="sd">    </span>
<span class="sd">    :return: The feature vector representation of the JSON data.</span>
<span class="sd">    :rtype: torch.Tensor</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; json_data = {&quot;text&quot;: &quot;This is a sample text.&quot;}</span>
<span class="sd">        &gt;&gt;&gt; encoder = SequenceEncoder(&quot;bert-base-uncased&quot;)</span>
<span class="sd">        &gt;&gt;&gt; feature_vector = json_to_feature_vector(json_data, encoder)</span>
<span class="sd">        &gt;&gt;&gt; print(feature_vector)</span>
<span class="sd">        tensor([[0.1234, 0.5678, ..., 0.9876]])</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; json_data = {&quot;text&quot;: &quot;Another example text.&quot;}</span>
<span class="sd">        &gt;&gt;&gt; feature_vector = json_to_feature_vector(json_data, &quot;bert-base-uncased&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(feature_vector)</span>
<span class="sd">        tensor([[0.5678, 0.4321, ..., 0.8765]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Example function to convert JSON to a feature vector</span>
    <span class="c1"># This should be aligned with how the original features were generated</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sentence_encoder</span><span class="p">,</span> <span class="n">SequenceEncoder</span><span class="p">):</span>
        <span class="c1"># could either pass the model name in huggingface, or directory holding models </span>
        <span class="n">sentence_encoder</span> <span class="o">=</span> <span class="n">SequenceEncoder</span><span class="p">(</span><span class="n">sentence_encoder</span><span class="p">)</span>
    
    <span class="c1"># clear json if the entry holds emply list</span>
    <span class="n">k_del_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">json_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="p">[]]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k_del_list</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">json_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="n">feature_vector</span> <span class="o">=</span> <span class="n">sentence_encoder</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">json_data</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">feature_vector</span></div>



<div class="viewcode-block" id="add_new_position_node">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.add_new_position_node">[docs]</a>
<span class="k">def</span> <span class="nf">add_new_position_node</span><span class="p">(</span><span class="n">hetero_data</span><span class="p">,</span> <span class="n">json_data</span><span class="p">,</span> <span class="n">sentence_encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">techstack_mapping</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a new &#39;position&#39; node with edges to &#39;techStack&#39; nodes based on JSON data.</span>

<span class="sd">    This function adds a new &#39;position&#39; node to the heterogeneous graph data and</span>
<span class="sd">    creates edges to &#39;techStack&#39; nodes based on the information provided in the JSON data.</span>

<span class="sd">    :param hetero_data: The heterogeneous graph data to which the new node and edges will be added.</span>
<span class="sd">    :param json_data: JSON data containing information about the new &#39;position&#39; node</span>
<span class="sd">        and its related &#39;techStack&#39; nodes.</span>
<span class="sd">    :param sentence_encoder: An instance of a sentence encoder model or the name/directory path</span>
<span class="sd">        of a pre-trained sentence encoder model to be used for encoding descriptions.</span>
<span class="sd">    :param techstack_mapping: A dictionary mapping tech stack names to their corresponding indices.</span>
<span class="sd">    :param device: The device (e.g., &#39;cpu&#39; or &#39;cuda&#39;) to be used for tensor operations.</span>
<span class="sd">    </span>
<span class="sd">    :return: A tuple containing the updated heterogeneous graph data and the index of the new &#39;position&#39; node.</span>
<span class="sd">    :rtype: Tuple[YourHeteroData, int]</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; json_data = {&quot;&quot;: &quot;Software Engineer&quot;, &quot;&quot;: [&quot;Python&quot;, &quot;JavaScript&quot;]}</span>
<span class="sd">        &gt;&gt;&gt; hetero_data, position_idx = add_new_position_node(hetero_data, json_data, sentence_encoder, techstack_mapping, &#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(position_idx) # 42</span>
<span class="sd">        &gt;&gt;&gt; print(hetero_data) # &lt;YourHeteroData ...&gt;</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; json_data = {&quot;&quot;: &quot;Data Scientist&quot;, &quot;&quot;: [&quot;Python&quot;, &quot;R&quot;]}</span>
<span class="sd">        &gt;&gt;&gt; hetero_data, position_idx = add_new_position_node(hetero_data, json_data, &quot;bert-base-uncased&quot;, techstack_mapping, &#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(position_idx)</span>
<span class="sd">        43</span>
<span class="sd">        &gt;&gt;&gt; print(hetero_data)</span>
<span class="sd">        &lt;YourHeteroData ...&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">hetero_data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    
    <span class="c1"># Convert numpy array to torch tensor</span>
    <span class="n">feature_vector</span> <span class="o">=</span> <span class="n">json_to_feature_vector</span><span class="p">(</span><span class="n">json_data</span><span class="p">,</span> <span class="n">sentence_encoder</span><span class="p">)</span>
    <span class="n">feature_vector</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">feature_vector</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># Add the new position node</span>
    <span class="n">new_position_idx</span> <span class="o">=</span> <span class="n">hetero_data</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Index of the new position node</span>
    <span class="n">hetero_data</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">hetero_data</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">feature_vector</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">new_position_name</span> <span class="o">=</span> <span class="n">json_data</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
    <span class="n">hetero_data</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">][</span><span class="s2">&quot;mapping&quot;</span><span class="p">][</span><span class="n">new_position_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_position_idx</span>

    <span class="c1"># Prepare to add new edges for &#39;position&#39;-&#39;techStack&#39; relationship</span>
    <span class="n">techstack_names</span> <span class="o">=</span> <span class="n">json_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">techstack_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;mapping&quot;</span> <span class="ow">in</span> <span class="n">hetero_data</span><span class="p">[</span><span class="s2">&quot;techStack&quot;</span><span class="p">]:</span>
            <span class="n">techstack_mapping</span> <span class="o">=</span> <span class="n">hetero_data</span><span class="p">[</span><span class="s2">&quot;techStack&quot;</span><span class="p">][</span><span class="s2">&quot;mapping&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;You need to give the techStack mapping: name --&gt; index !!!&quot;</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">tech_name</span> <span class="ow">in</span> <span class="n">techstack_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tech_name</span> <span class="ow">in</span> <span class="n">techstack_mapping</span><span class="p">:</span>
            <span class="n">techstack_idx</span> <span class="o">=</span> <span class="n">techstack_mapping</span><span class="p">[</span><span class="n">tech_name</span><span class="p">]</span>
            <span class="n">new_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_position_idx</span><span class="p">,</span> <span class="n">techstack_idx</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">new_edges</span><span class="p">:</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">new_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">hetero_data</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;needTechstack&#39;</span><span class="p">,</span> <span class="s1">&#39;techStack&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">hetero_data</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;needTechstack&#39;</span><span class="p">,</span> <span class="s1">&#39;techStack&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span><span class="si">}</span><span class="s2"> new edges added.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hetero_data</span><span class="p">,</span> <span class="n">new_position_idx</span></div>



<div class="viewcode-block" id="score_and_rank_employees">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.score_and_rank_employees">[docs]</a>
<span class="k">def</span> <span class="nf">score_and_rank_employees</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">hetero_data</span><span class="p">,</span> <span class="n">new_position_idx</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Score and rank employees based on compatibility with a new &#39;position&#39; node.</span>

<span class="sd">    This function scores and ranks employees based on their compatibility with a new &#39;position&#39; node</span>
<span class="sd">    that was added to the heterogeneous graph. Compatibility is calculated using embeddings obtained</span>
<span class="sd">    from a trained heterogeneous graph neural network model.</span>

<span class="sd">    :param YourHeteroGNN model: The trained heterogeneous graph neural network model.</span>
<span class="sd">    :param YourHeteroData hetero_data: The heterogeneous graph data containing employees and the new &#39;position&#39;.</span>
<span class="sd">    :param int new_position_idx: The index of the new &#39;position&#39; node in the graph.</span>
<span class="sd">    :param str device: The device (e.g., &#39;cpu&#39; or &#39;cuda&#39;) to be used for tensor operations.</span>
<span class="sd">    </span>
<span class="sd">    :return: Two tensors containing sorted indices and corresponding scores of employees.</span>
<span class="sd">    :rtype: Tuple[torch.Tensor, torch.Tensor]</span>

<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; model = YourHeteroGNN()</span>
<span class="sd">    &gt;&gt;&gt; hetero_data = YourHeteroData()</span>
<span class="sd">    &gt;&gt;&gt; new_position_idx = 42</span>
<span class="sd">    &gt;&gt;&gt; sorted_indices, sorted_scores = score_and_rank_employees(model, hetero_data, new_position_idx, &#39;cuda&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sorted_indices)</span>
<span class="sd">    tensor([10, 5, 20, ...])</span>
<span class="sd">    &gt;&gt;&gt; print(sorted_scores)</span>
<span class="sd">    tensor([0.9876, 0.8765, 0.7654, ...])</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; model = YourHeteroGNN()</span>
<span class="sd">        &gt;&gt;&gt; hetero_data = YourHeteroData()</span>
<span class="sd">        &gt;&gt;&gt; new_position_idx = 43</span>
<span class="sd">        &gt;&gt;&gt; sorted_indices, sorted_scores = score_and_rank_employees(model, hetero_data, new_position_idx, &#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(sorted_indices)</span>
<span class="sd">        tensor([15, 12, 30, ...])</span>
<span class="sd">        &gt;&gt;&gt; print(sorted_scores)</span>
<span class="sd">        tensor([0.8765, 0.7654, 0.6543, ...])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">hetero_data</span> <span class="o">=</span> <span class="n">hetero_data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">hetero_data</span><span class="o">.</span><span class="n">x_dict</span><span class="p">,</span> <span class="n">hetero_data</span><span class="o">.</span><span class="n">edge_index_dict</span><span class="p">)</span>

    <span class="c1"># Get the embedding of the new position</span>
    <span class="n">position_embedding</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">][</span><span class="n">new_position_idx</span><span class="p">]</span>

    <span class="c1"># Get the embeddings of all employees</span>
    <span class="n">employee_embeddings</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="s1">&#39;employee&#39;</span><span class="p">]</span>

    <span class="c1"># Calculate compatibility scores (e.g., using dot product)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">employee_embeddings</span><span class="p">,</span> <span class="n">position_embedding</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># Rank employees based on scores</span>
    <span class="n">sorted_scores</span><span class="p">,</span> <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sorted_indices</span><span class="p">,</span> <span class="n">sorted_scores</span></div>



<span class="k">def</span> <span class="nf">_reverse_mapping</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse the keys and values of a dictionary.</span>

<span class="sd">    This function takes a dictionary as input and returns a new dictionary where</span>
<span class="sd">    the keys and values are reversed.</span>

<span class="sd">    :param dict mapping_dict: The dictionary to be reversed.</span>
<span class="sd">    </span>
<span class="sd">    :return: A new dictionary with keys and values reversed.</span>
<span class="sd">    :rtype: dict</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; original_dict = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
<span class="sd">        &gt;&gt;&gt; reversed_dict = _reverse_mapping(original_dict)</span>
<span class="sd">        &gt;&gt;&gt; print(reversed_dict)</span>
<span class="sd">        {1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reversed_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">index</span><span class="p">:</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">reversed_dict</span>


<div class="viewcode-block" id="recommend">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.recommend">[docs]</a>
<span class="k">def</span> <span class="nf">recommend</span><span class="p">(</span><span class="n">json_request</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sentence_encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">topk</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recommend top employees for a new position based on JSON request and model.</span>

<span class="sd">    This function recommends the top employees for a new position based on the provided JSON request,</span>
<span class="sd">    a trained recommendation model, and existing data. It calculates compatibility scores for employees</span>
<span class="sd">    and ranks them to provide the top recommendations.</span>

<span class="sd">    :param dict json_request: JSON request containing information about the new &#39;position&#39; node.</span>
<span class="sd">    :param model: The trained recommendation model.</span>
<span class="sd">    :param data: The heterogeneous graph data containing employee and &#39;position&#39; nodes.</span>
<span class="sd">    :param sentence_encoder: An instance of a sentence encoder model or the name/directory path</span>
<span class="sd">        of a pre-trained sentence encoder model to be used for encoding descriptions.</span>
<span class="sd">    :param int topk: The number of top recommendations to return (default is 5).</span>
<span class="sd">    :param int verbose: Verbosity level (0 for no output, 1 for minimal output).</span>
<span class="sd">    </span>
<span class="sd">    :return: A list of tuples containing recommended employee names and their corresponding scores.</span>
<span class="sd">    :rtype: List[Tuple[str, float]]</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; json_request = {&quot;&quot;: &quot;Software Engineer&quot;, &quot;&quot;: [&quot;Python&quot;, &quot;JavaScript&quot;]}</span>
<span class="sd">        &gt;&gt;&gt; recommendations = recommend(json_request, model, data, sentence_encoder, topk=3, verbose=1)</span>
<span class="sd">        &gt;&gt;&gt; for employee, score in recommendations:</span>
<span class="sd">        ...     print(f&quot;Employee: {employee}, Score: {score}&quot;)</span>
<span class="sd">        Employee: John Smith, Score: 0.9876</span>
<span class="sd">        Employee: Sarah Brown, Score: 0.8765</span>
<span class="sd">        Employee: Michael Johnson, Score: 0.7654</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
    
    <span class="n">new_hetero_data</span><span class="p">,</span> <span class="n">new_position_idx</span> <span class="o">=</span> <span class="n">add_new_position_node</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">json_request</span><span class="p">,</span> <span class="n">sentence_encoder</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">new_hetero_data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">sentence_encoder</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    
    <span class="n">ranked_employee_indices</span><span class="p">,</span> <span class="n">ranked_scores</span> <span class="o">=</span> <span class="n">score_and_rank_employees</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">new_hetero_data</span><span class="p">,</span> <span class="n">new_position_idx</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
    
    <span class="c1"># Get top k recommended employees</span>
    <span class="n">top_employees</span> <span class="o">=</span> <span class="n">ranked_employee_indices</span><span class="p">[:</span><span class="n">topk</span><span class="p">]</span>
    <span class="n">top_scores</span> <span class="o">=</span> <span class="n">ranked_scores</span><span class="p">[:</span><span class="n">topk</span><span class="p">]</span>
    
    <span class="c1"># Display recommendations</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">employee_reverse_mapping</span> <span class="o">=</span> <span class="n">_reverse_mapping</span><span class="p">(</span><span class="n">new_hetero_data</span><span class="p">[</span><span class="s2">&quot;employee&quot;</span><span class="p">][</span><span class="s2">&quot;mapping&quot;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_employees</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">top_scores</span><span class="o">.</span><span class="n">tolist</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Employee ID: </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">, Name: </span><span class="si">{</span><span class="n">employee_reverse_mapping</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="si">}</span><span class="s2">, Score: </span><span class="si">{</span><span class="n">score</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">employee_reverse_mapping</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">score</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">outs</span></div>



<div class="viewcode-block" id="similarity_compute">
<a class="viewcode-back" href="../../talent_recommendation.html#talent_recommendation.BipartiteRecSys.similarity_compute">[docs]</a>
<span class="k">def</span> <span class="nf">similarity_compute</span><span class="p">(</span>
    <span class="n">input_request</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">configs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="n">topk</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute and return employee recommendations based on a similarity input request.</span>

<span class="sd">    This function computes employee recommendations based on a similarity input request</span>
<span class="sd">    by utilizing a trained recommendation model, heterogeneous graph data, and a sentence encoder.</span>

<span class="sd">    :param str input_request: The input request describing the new &#39;position&#39; node.</span>
<span class="sd">    :param Union[str, Dict[str, Any]] configs: Configuration information in the form of a dictionary</span>
<span class="sd">        or the path to a configuration file.</span>
<span class="sd">    :param int topk: The number of top recommendations to return (default is 5).</span>
<span class="sd">    :param Union[str, Path, None] data: The path to a saved HeteroData object or None.</span>
<span class="sd">    :param Any model: The trained recommendation model or None.</span>
<span class="sd">    :param int verbose: Verbosity level (0 for no output, 1 for minimal output).</span>
<span class="sd">    </span>
<span class="sd">    :return: A tuple containing a DataFrame with employee information and a list of recommended employees with scores.</span>
<span class="sd">    :rtype: Tuple[pd.DataFrame, List[Tuple[str, float]]]</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; input_request = &quot;We are looking for a Python Developer with experience in web development.&quot;</span>
<span class="sd">        &gt;&gt;&gt; config_file = &quot;config.yaml&quot;</span>
<span class="sd">        &gt;&gt;&gt; recommendations_df, recommendations = similarity_compute(input_request, config_file, topk=3, data=None, model=None, verbose=1)</span>
<span class="sd">        &gt;&gt;&gt; print(recommendations_df)</span>
<span class="sd">                     </span>
<span class="sd">        0  John Smith  Master&#39;s Degree   2010  35  [&#39;Python&#39;, &#39;JavaScript&#39;]</span>
<span class="sd">        1  Sarah Brown  Bachelor&#39;s Degree   2012  31  [&#39;Python&#39;, &#39;JavaScript&#39;]</span>
<span class="sd">        2  Michael Johnson  PhD   2009  37  [&#39;Python&#39;, &#39;JavaScript&#39;]</span>
<span class="sd">        &gt;&gt;&gt; print(recommendations)</span>
<span class="sd">        [(&#39;John Smith&#39;, 0.9876), (&#39;Sarah Brown&#39;, 0.8765), (&#39;Michael Johnson&#39;, 0.7654)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># load configs</span>
    <span class="n">configs</span> <span class="o">=</span> <span class="n">load_configs</span><span class="p">(</span><span class="n">configs</span><span class="p">,</span> <span class="n">check_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">])</span>

    
    <span class="c1"># connect to neo4j</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">Neo4jAPI</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">][</span><span class="s2">&quot;url&quot;</span><span class="p">],</span> <span class="n">configs</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">][</span><span class="s2">&quot;user&quot;</span><span class="p">],</span> <span class="n">configs</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">][</span><span class="s2">&quot;password&quot;</span><span class="p">])</span>
    
    <span class="c1"># load data  </span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">load_dataset</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;save&quot;</span> <span class="ow">in</span> <span class="n">configs</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="s1">&#39;save&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;data&quot;</span> <span class="ow">in</span> <span class="n">configs</span><span class="p">[</span><span class="s1">&#39;save&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found HeteroData at </span><span class="si">{</span><span class="n">configs</span><span class="p">[</span><span class="s1">&#39;save&#39;</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">load_dataset</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="s1">&#39;save&#39;</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No dataset found. Fetch data from neo4j database.&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">load_hetero_graph_dataset</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="s2">&quot;neo4j&quot;</span><span class="p">][</span><span class="s2">&quot;labels&quot;</span><span class="p">])</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">ToUndirected</span><span class="p">()(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">configs</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">metadata</span><span class="p">()</span>
    
    <span class="c1"># load model</span>
    <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">(</span><span class="n">HeteroGNN</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">configs</span><span class="p">[</span><span class="s1">&#39;graphNeuralNetwork&#39;</span><span class="p">]),</span> <span class="n">path</span><span class="o">=</span><span class="n">configs</span><span class="p">[</span><span class="s1">&#39;save&#39;</span><span class="p">][</span><span class="s1">&#39;model&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No model could be found. Now we are going to train a model.&quot;</span><span class="p">)</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">rec_sys_train</span><span class="p">(</span><span class="n">configs</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    
    <span class="c1"># load sentence encoder</span>
    <span class="n">sentence_encoder</span> <span class="o">=</span> <span class="n">SequenceEncoder</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="s2">&quot;sentence_encoder&quot;</span><span class="p">])</span>
    
    <span class="c1"># compute and query</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">recommend</span><span class="p">(</span><span class="n">input_request</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sentence_encoder</span><span class="p">,</span> <span class="n">topk</span><span class="o">=</span><span class="n">topk</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    <span class="c1"># get the output people</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            MATCH (e:employee)-[:hasTechStack]-(t:techStack)</span>
<span class="s2">            WHERE e.name = &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="s2">            RETURN e.name AS ``, </span>
<span class="s2">                e.`` AS ``, </span>
<span class="s2">                e.`` AS ``,</span>
<span class="s2">                date().year - date(e.``).year AS ``,</span>
<span class="s2">                COLLECT(t.name) AS ``</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">fetch_data</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="c1"># this employee has no links to techStack</span>
            <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                MATCH (e:employee)</span>
<span class="s2">                WHERE e.name = &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="s2">                RETURN e.name AS ``, </span>
<span class="s2">                    e.`` AS ``, </span>
<span class="s2">                    e.`` AS ``,</span>
<span class="s2">                    date().year - date(e.``).year AS ``</span>
<span class="s2">            &quot;&quot;&quot;</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">fetch_data</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">fetch_data</span><span class="p">(</span><span class="n">query</span><span class="p">))</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">outs</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">RecSysAlgo</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">KnowledgeAlgorithms</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, ywenxi.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>